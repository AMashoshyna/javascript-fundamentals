

Итерирование в программировании - это подход, при котором фрагмент кода выполняется многократно (некоторое заданное число раз).
Итерировать - в буквальном значении "повторять". Когда мы итерируем по массиву, мы выполняем некий кусок кода для каждого элемента в массиве (повторяем столько раз, сколько в массиве содержится элементов).

С точки зрения реализации итерирование подразумевает наличие сущностей двух типов - производителей данных (Data sources или Data producers) и потребителей данных (Data consumers). Например, цикл `for...of` потребляет данные, производимые массивом:

```javascript

for(let i of [1, 2, 3]) {
   console.log(i);       // [1,2,3];
}
```
Spread operator также потребляет данные, производимые массивом

```javascript

const initialArr = [1, 2, 3];
const copy = [...initialArr]; // [1,2,3];

```
До выхода ES6 в JavaScript взаимодействие потребителей и производителей данных было разношерстным, но с приходом ES6 появился единый интерфейс для взаимодействия потребителей и производителей данных - `Iterable`. Сущности стандартной бибилиотеки, такие как массивы и строки, реализуют этот интерфейс. Авторы прикладного кода также могут его использовать. Так как полноценных интерфейсов в JavaScript нет, речь идет скорее о контракте или конвенции.


Начнем с нескольких важных понятий.

**Iterable** (итерируемая сущность) - объект, по которому можно итерировать. Чтобы быть iterable, объект должен реализовывать метод `Symbol.iterator`, который при вызове возвращает итератор.

**Iterator** (итератор) - сущность, которая определяет последовательность перебора значений. Значения можно перебирать, вызывая метод `next()`, наличие которого для итератора обязательно. Таким образом, чтобы быть итератором, объект должен реализовывать метод `next()`, который при вызове возвращает объект вида `{value: any, done: boolean}`. value - значение на текущей итерации, `done` - флаг, указывающий на то, является ли эта итерация последней (есть ли еще значения).

Вместе iterable и iterator входят в протокол итерирования.

**Consumer** - контекст, который ожидает iterable, и умеет с ним работать. Примеры синтаксических конструкций, которые создают такой контекст:
- for ... of
- spread operator
- Promise.all()

Задание: в консоли передайте в перечисленным выше контекстам пустой объект и посмотрите, какая появится ошибка. Например, введите `Promise.all({})`.

Пример взаимодействия data consumer и data source:
```javascript
// TODO
```

Многие сущности стандартной бибилиотеки JavaScript являются итерируемыми. Примера таких сущностей являются массивы и строки, которые реализуют метод `Symbol.iterator`.
Посмотрим на работу этого метода. Вызов `Symbol.iterator` возвращает объект итератора, который можно сохранить в переменную. Обратите внимание на то, что итератор имеет состояние - запоминает, какое значение он возвращал, а при каждом вызове метода `Symbol.iterator` возвращается новый экземпляр итератора, иначе итерировать массив можно было бы только один раз.
Убедимся в том, что массивы и строки - итерируемые.

```javascript
const myArr = [1,2,3];
typeof myArr[Symbol.iterator] // function;
const arrayIterator = myArr[Symbol.iterator]();
arrayIterator.next(); // {value: 1, done: false}
arrayIterator.next(); // {value: 2, done: false}
arrayIterator.next(); // {value: 3, done: false}
arrayIterator.next(); // {value: undefined, done: true}
```

Задание: проитерируйте строку по примеру выше и убедитесь, что строки в JavaScript также итерируемые.

Нам не обязательно ограничиваться встроенными итерируемыми объектами. Мы можем в соответствии с интерфейсом `Iterable` добавить возможность перебора любому объекту, описав порядок (алгоритм) перебора элементов и возвращаемое значение.

Зачем нам может это понадобиться?
Например, для обхода дерева // TODO
Для перебора свойств объекта, когда какие-то свойства нужно пропускать (они приватные). Вспомните массив: в нем есть свойства, лежащие по целочисленным ключам и при переборе мы их увидим, но также есть свойства, которые в переборе не участвуют, например `Array.prototype.length`. В реализованных нами объектах мы тоже можем использовать такой подход.

Для реализации собственного `Iterable` нам нужно определить на объекте функцию `Symbol.iterator`, которая возвращает объект с методом `next()`(итератор). Метод `next()`, в свою очередь, должен возвращать объект вида `{value: any, done: boolean}`. `value` - значение на текущей итерации, `done` - флаг, указывающий на то, является ли эта итерация последней (есть ли еще значения).

Напишем объект, которые при итерировании возвращает числа от 0 до 10:

```javascript
const myNewIterable = {
  [Symbol.iterator]() {
    // здесь хранится состояние итератора
    let currentValue = 0;
    let maxValue = 10;
    return {
      // этот метод будет вызывать код, использующий итератор
      next() {
        if (currentValue > maxValue) {
          return { value: undefined, done: true };
        } else {
          return {
            value: currentValue++,
            done: false,
          };
        }
      },
    };
  },
};

for (let i of myNewIterable) {
  console.log(i);
}

```

Этот итератор работает, но выглядит не очень полезным. Давайте напишем итератор для перебора свойств объекта. Скажем, у нас есть объект подобной структуры

```javascript
const authors = {
      fiction: [
         'Tolkien',
         'Lem'
      ],
      fantasy: [
         'Pratchett',
         'Rowling'
      ],
      scienceFiction: [
         'Asimov',
         'Clarke'
      ]
}
```
Мы хотели бы перебрать всех авторов, но структура данных такова, что авторы рассортированы по жанрам, а мы хотим получить единый список. Напишем свой итератор, который позволит это сделать.

```javascript
const authors = {
   // авторы, рассортированные по жанрам - см. структуру данных выше
}
const iterableAuthors = {

     {...authors}, // скопируем исходный данные в новый объект
    [Symbol.iterator](){
       const genres = Object.keys(this);
       const authors = genres.reduce((acc, genre) => acc.concat(this[genre]) ,[] );
       let currentAuthorIndex = 0;

       return {
         next() {
            if(currentAuthorIndex < authors.length) {
                return {
                    value: authors[currentAuthorIndex++],
                    done: false
                }
            }
            return {
                done: true
            }
         }
      }
   }
};

for(let author of iterableAuthors) { console.log(author)};
```

Писать итераторы вручную можно, но довольно неудобно, потому что нужно следить за внутренним состоянием итератора. Альтерантива - использование функций-генераторов. Функции-генераторы - это функции, выполнение которых можно приостанавливать. В теле функции-генератора можно использовать ключевое слово `yield`, после которого выполнение функции останавливается до момента, когда его продолжит вызывающий код. `yeild` отдает вызывающему коду итератор (то есть, объект, реализующий метод `next()`) и для продолжения выполнения тела функции-генератора нужно вызвать `next()`.


```javascript


const authors = {
   // авторы, рассортированные по жанрам - см. структуру данных выше
}
const iterableAuthors = {

     {...authors},
    [Symbol.iterator]: function*(){
        const genres = Object.keys(this);
        const authors = genres.reduce((acc, genre) => acc.concat(this[genre]) ,[] );
        let i = 0;
        while(i <= authors.length) {
            yield authors[i];
            i++;
        }
   }
};

for(let author of iterableAuthors) { console.log(author) };

```

Особенностью генераторов являются ленивые вычисления - значения будут вычислены тогда, когда они понадобятся. Это делает генераторы очень удобными для вычисления условно-бесконечных последовательностей (например, генерации ID или последовательности простых чисел). Генераторы удобно использовать, когда значения неизвестны заранее и вычисляются после вызова `.next()`.

Пример использования генераторов - генерация бесконечно повторяющегося массива
https://itnext.io/a-quick-practical-use-case-for-es6-generators-building-an-infinitely-repeating-array-49d74f555666


Задание: напишите генератор четных чисел

```javascript
const getEvenNumbersGenerator() {
   // your code here
}
const myGenerator = getEvenNumbersGenerator(); 

myGenerator.next().value // 2
myGenerator.next().value // 4 etc.
```

Объясните своими словами, чем отличаются итераторы, итерируемые сущности и генераторы.